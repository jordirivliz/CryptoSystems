# Helper functions, feel free to use them below.
def str2num(s): #takes as input a string of characters, capitalizes it and returns the integer obtained by concatenating the corresponding  ASCII codes
    return ZZ(''.join([str(ord(i)) for i in s.upper()]))

def num2str(m): #the inverse of the function in (a), takes as input an integer and returns the corresponding message (capitalized)
    m=str(m)
    return ''.join(chr(int(m[i:i+2])) for i in range(0,len(m),2))

# This function takes input a nonempty list T of integers and an integer c and generates a square matrix of dimension 2+n where n = len(T)-1
def mhlattice(T,c):
    if len(T) <= 0:
        return 'Invalid input'
    if type(c) != Integer:
        return 'Invalid input'
    n = len(T) - 1
    # Create identity matrix and multiply by 2
    M = matrix.identity(n+1)
    M = 2*M
    # Extract the columns
    columns = M.columns()
    # Add the vector T as the last column
    v = vector(T)
    columns.append(v)
    M = Matrix(columns).transpose()
    # Add all 1's and c at the last row
    lst = [1 for i in range(n+1)]
    lst.append(c)
    # Create the last row
    w = vector(lst)
    rows = M.rows()
    # Add new row to the rows in M
    rows.append(w)
    M = Matrix(rows)
    return M
    
def mhbreak(T,c):
    if type(c) != Integer:
        return 'Invalid input'
    # Sets M = mhlattice(T,c)
    M = mhlattice(T,c)
    # Runs LLL on the lattice generated by the rows of MM by setting ML = M.LLL()
    ML = M.LLL()
    # Sets w = the shortest row in ML which is always the first row in the M.LLL() matrix
    w = ML[0]
    # Finds v such that w = v*M
    v = M.solve_left(w)
    # Returns the binary sequence of length n + 1 = len(T) that consists of 1 wherever v has âˆ’1 in that position and 0 in the other positions
    output = [0]*len(T)
    for i in range(len(T)):
        if v[i] == -1:
            output[i] = 1
        else:
            output[i] = 0
    return output
